# Database hw12

### 问题 1

（1）

- - 执行顺序 T1 -> T2 -> T3:
    - T1: A = 0 + 2 = 2
    - T2: A = 2 * 2 = 4
    - T3: A = 4 ** 2 = 16
  - 执行顺序 T1 -> T3 -> T2:
    - T1: A = 0 + 2 = 2
    - T3: A = 2 ** 2 = 4
    - T2: A = 4 * 2 = 8
  - 执行顺序 T2 -> T1 -> T3:
    - T2: A = 0 * 2 = 0
    - T1: A = 0 + 2 = 2
    - T3: A = 2 ** 2 = 4
  - 执行顺序 T2 -> T3 -> T1:
    - T2: A = 0 * 2 = 0
    - T3: A = 0 ** 2 = 0
    - T1: A = 0 + 2 = 2
  - 执行顺序 T3 -> T1 -> T2:
    - T3: A = 0 ** 2 = 0
    - T1: A = 0 + 2 = 2
    - T2: A = 2 * 2 = 4
  - 执行顺序 T3 -> T2 -> T1:
    - T3: A = 0 ** 2 = 0
    - T2: A = 0 * 2 = 0
    - T1: A = 0 + 2 = 2

因此，可能的正确结果为：0, 2, 4, 8, 16。

（2）调度顺序：T1 -> T2 -> T3。执行结果为 16。

（3）T1 和 T2 可以同时执行。在 T1 完成之前意义不明确的 T2 执行可能导致无法确定结果。

（4）按照两段锁协议严格顺序执行：

- - T1 获取锁，执行更新，释放锁。
  - T2 获取锁，执行更新，释放锁。
  - T3 获取锁，执行更新，释放锁。

调度顺序为：T1 -> T2 -> T3，不产生死锁。

（5）T1 和 T2 同时尝试获取锁，且由于顺序不定产生死锁：T1 获取 A 的锁并尝试获取 B 的锁，T2 获取 B 的锁并尝试获取 A 的锁。

### 问题 2

- T3 通过读写 B 与其他事务冲突。
- T1 读写 A 冲突。
- T2 通过读写 B 冲突。

不是冲突可串行化。

### 问题 3

（1）改写 T1 和 T2，增加加锁操作和解锁操作，并要求遵循两阶段封锁协议。

- T1:

  ```
  Lock(B);
  Lock(A);
  R(A);
  R(B);
  B = A + B;
  W(B);
  Unlock(B);
  Unlock(A);
  ```

- T2:

  ```
  Lock(A);
  Lock(B);
  R(B);
  R(A);
  A = A + B;
  W(A);
  Unlock(A);
  Unlock(B);
  ```

（2）互相保持锁的过程会导致死锁

- T1 获取 A 锁，然后 T2 获取 B 锁。
- T1 试图获取 B 锁，但被 T2 持有。
- T2 试图获取 A 锁，但被 T1 持有。

