# Database

## 数据库系统概论

### 数据库系统概述

数据库(DataBase,简称DB),是长期储存在计算机内、有组织、可共享的大量数据集合。

层次网状数据库→关系数据库系统→新一代数据库系统

数据库管理系统是个软件，数据定义功能，数据存储、管理、组织功能，数据操纵功能，数据库的事务管理和运行管理，数据库的建立和维护

数据库系统包括软硬件，由数据库、数据库管理系统(及其应用开发工具)、应用系统、数据库管理员(DataBase Administrator, DBA)构成

数据库的基本特征：数据按一定的数据模型组织、描述和储存;  Ø 可为各种用户共享;  Ø 冗余度较小（但是仍然有冗余）;  Ø 数据独立性较高（应用程序与数据库中存储的数据独立）;  Ø 易扩展;

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image.png)

### 数据库管理技术

人工管理（40-50年代）-文件系统（50-60，共享性、冗余度、独立性差）-数据库系统阶段

### 数据库系统的基本特点

1. 结构化是主要特征之一，数据的最小存取单位是数据项。不仅仅针对一个应用
2. 数据的独立性
    1. 物理独立性  指用户的应用程序与存储在物理磁盘上的数据库中数据是相互独立的
    2. 逻辑独立性  指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了,用户程序也可以不变。
3. 高共享性，降低冗余度，避免不一致性，易于扩充
4. 安全性
5. 完整性：正确/有效/相容
6. 并发控制&数据库恢复

### 数据模型

1. 概念模型
    
    抽象、表示和处理现实世界中的数据和信息
    
    客观事物→概念模型（用户的观点）→逻辑模型（存到计算机）
    
    1. 实体，客观存在且可以互相区别的事物
    2. 属性：实体的某一特性
    3. 码：唯一标识实体的属性集称为码。
    4. 域(Domain)  属性的取值范围称为该属性的域。  
    5. 实体型(Entity Type)  用实体名及其属性名集合来抽象和刻画 同类实体称为实体型  
    6. 实体集(Entity Set)  同型实体的集合称为实体集，**有数量这个概念**
    7. 联系：实体内部的联系/实体之间的联系。*参与联系的实体型的数目,称为联系的度*
    
    实体-联系模型（E-R）实体型矩形，椭圆形属性，联系菱形，联系可以有属性
    
    TODO：什么时候可以建立多个实体间的联系，什么时候不合并？根据用户需求，比如教室，学生，老师，学生可能和教室有其他时候的联系，需要语义更丰富。如果经常出现，可以合并。多个实体之间的多对多：需要每个实体之间都要有联系，可以建立一个三列的表试一试。除非一起说，就两个两个写。属性不能是教授/副教授，应该是职称
    
2. 逻辑模型和物理模型
    
    数据模型的组成要素：数据结构——静态特性，数据操作——动态特性，数据的完整性约束条件
    
    数据结构：描述数据库的组成对象和对象之间的联系
    
    1. 层次模型  满足下面两个条件的基本层次联系的集合为层次模型:  1. 有且只有一个结点没有双亲结点,  这个结点称为根结点。  2. 根以外的其它结点有且只有一个双亲结点。联系:用结点之间的连线(有向边)表示记录(类型)之间的  一对多的父子联系。
        
        完整性约束：无相应的双亲结点值就不能插入子女结点值;  Ø 如果删除双亲结点值,则相应的子女结点值也被同时删除;  Ø 更新操作时,应更新所有相应记录,以保证数据的一致性;
        
    2. 网状模型
        1. 允许多个节点没有双亲的节点，一个节点可以有多个双亲。多对多分解为一对多
    3. 关系模型
        1. 一个实体型就是一张表
        2. 关系的规范条件：关系的每一个分量必须是不可分的数据项，即不允许表中还有表
        3. 完整性约束：实体（主码有且唯一）、参照（外码满足引用关系）、用户定义的完整性（个性化需求，比如员工工资必须大于1000元/月）

### 数据库系统结构

数据库采用三级模式结构，提高独立性

型(Type)  对某一类数据的结构和属性的说明;  值(Value)  是型的一个具体赋值;记录型: (学号,姓名,性别,系别,年龄,籍贯)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%201.png)

模式(也称逻辑模式) 是数据库中全体数据的逻辑结构和特征的描述;  是所有用户的公共数据视图,综合了所有用户的需求;  **一个应用数据库只有一个模式,以数据模型为基础**

- 与数据的物理存储细节和硬件环境无关，与具体的应用程序、开发工具及高级程序设计语言无关

外模式：数据库用户(包括应用程序员和最终用户)使用的逻辑结构和特征的描述

- 模式与外模式的关系:一对多；外模式与应用的关系:一对多
- 保证数据库安全

内模式：是数据物理结构和存储方式的描述

二级映象,在DBMS内部实现这三个抽象层次的联系和转换;  

- 外模式/模式映像 逻辑独立性，需要根据模式修改
- 模式/内模式映像 物理独立性

## 关系模型和关系运算理论

### 关系数据结构

关系就是二维表格

1. 关系(Relation)  一个关系对应通常说的一张表。  
2. 元组(Tuple)  表中的一行即为一个元组。  
3. 属性(Attribute)  表中的一列即为一个属性,给每一个属性起一个名称即属性
4. 主码(Key)  表中的某个属性组,它可以唯一确定一个元组。  
5. 域(Domain)  属性的取值范围来自某个域。  
6. 分量  元组中的一个属性值。  
7. 关系模式  对关系的描述  关系名(属性1,属性2,...,属性n)  学生(学号,姓名,年龄,性别,系,年级)

关系模型的数据结构
实体及实体间的联系的表示方法:  

1. 实体型:直接用关系(表)表示。  
2. 属性:用属性名表示。  例:学生(学号,姓名,年龄,性别,系号,年级)  课程(课程号,课程名,学分)  
3. 一对一联系:隐含在实体对应的关系中。  例:班级(班级号,班级人数,班长学号)  
4. 一对多联系:隐含在实体对应的关系中。  
5. 多对多联系:直接用关系表示。  例:选修(学号,课程号,成绩)

关系的每一个分量必须是一个不可分的数据项

数据操作是集合操作,操作对象和操作结果都是关系,  即若干元组的集合;

1. 优点：
    1. 建立在严格的数学概念的基础上;  
    2. 概念单一,数据结构简单、清晰,用户易懂易用  关系模型的存取路径对用户透明  具有更高的数据独立性,更好的安全保密性  
    3. 简化了程序员的工作和数据库开发建立的工作
2. 缺点:  Ø 存取路径对用户隐蔽,导致查询效率往往不如格式化数据模型;  Ø 为提高性能,必须对用户的查询请求进行优化,增加了开发数  据库管理系统的难度;

### 关系

基数等于做笛卡尔积的集合的基数的乘积

关系是笛卡尔积的子集

目是属性的个数

**若关系中的某一属性组的值能唯一地标识一个元组,而其子集不能,则称该属性组为候选码。**

在最极端的情况下,关系模式的所有属性组是这个关系模式的候选码,称为全码(All-key)（三个实体的一个联系）

若一个关系有多个候选码,则选定其中一个为主码

候选码的属性都是主属性，其他为非主属性，主属性不能为空

三类关系：基本表；查询表  查询结果对应的表；视图表：不同人看到的不同

数学中笛卡尔积不满足交换律，关系中可以

关系模式是型，关系是值

### 关系完整性

1. 实体完整性 主属性不能取空
2. 参数完整性：外码要么是空值要么是S 中某个元组的主码值
    
    外码是目标关系的，是参照关系的主码。两个关系可能是同一个关系（一对多合并了）
    
3. 用户定义的完整性

### 关系操作

查询  选择、投影、连接、除、交、并、差、笛卡儿积  

选择、投影、并、差、笛卡儿积为基本

数据更新  插入、删除、修改

操作的对象和结果都是集合

### 关系代数语言

**三要素**：运算对象:关系  运算结果:关系  运算符:四类

集合运算符(并、差、交、广义笛卡儿积)

专门的关系运算符(选择、投影、连接、除)  ü 不仅涉及行而且涉及列;

算术比较符  辅助专门的关系运算符进行操作;  

逻辑运算符  辅助专门的关系运算符进行操作;

1. t1弧线t2表示将两个元组连接起来
2.  

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%202.png)

1. 并：具有相同的目（属性个数）n 相应的属性取自同一个域;，R∪S = { t|t in R ∨t inS }
2. R∩S = R-(R-S)
3. 广义笛卡尔积：从两个集合取元组进行连接 m+n列，k1*k2行
4. 选择：σ_F(R) = { t|t in R ∧ F(t)= '真'}
5. 投影 π_A(R) = { t[A] | t in R }，会自动去掉重复的行，**先选择在投影**
6. 连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%203.png)
    
    1. 等值连接 条件是等号
    2. 自然连接，两个关系比较的是相同的属性组，结果中去掉重复的列属性。没有相同的元组称为悬浮元组 PI_(A,R.B,C,E)((sigma_(R.B=S.B)(RxS)))
    3. 外连接：把舍弃的元组也保存在结果关系中,而在其他属性上填空值(Null),
        1. 只把左边关系R中要舍弃的元组保留：左外连接
7. 除R÷S = { tr [X] | tr in R ∧ π_Y (S) in Yx } R与S的除运算得到一个新的关系P(X),P是R中满足下列条件的元组在X属性  列上的投影:元组在X上分量值x的象集Yx包含S在Y上投影的集合。
    
    最终得到的是x的集合
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%204.png)
    

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%205.png)

要用候选码来连接和筛选，要用最全的表来筛选。SC不包含所有学生/所有课程

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%206.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%207.png)

这里不需要再投影了

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%208.png)

这里可能用了别的供应商提供的这个零件

## 关系规范化基础

### 概念回顾

关系数据库是基于关系模型的数据库。关系数据库的模式:定义这组关系的关系模式的全体。

### 数据依赖

数据依赖是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系;

规范化理论正是用来改造关系模式,通过分解关系模式来  消除其中不合适的数据依赖,以解决插入异常、删除异常、更新异常和数据冗余问题。

函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖

如果X→Y,但Y不是X子集,则称X→Y是非平凡的函数依赖

完全函数依赖：对于X任何一个真子集都不能函数确定Y

如果X→Y,但Y不完全函数依赖于X,则称Y部分函数依赖于X,

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%209.png)

这里的直接是为了排除一些特殊的直接函数依赖也是传递函数依赖（比如多个候选码的情况下

候选码是最小的超码，不是完全函数确定每一个属性，因为存在部分函数确定

**一定要讲清楚外码是谁**

### 关系规范化

1. 第一范式：如果一个关系模式R的所有属性都是不可分的基本数据项
    
    展开/模式分解。如果我们有一个公司和它的员工信息表，而公司注册不需要立即提供员工信息，那么我们不能插入没有员工的公司记录。
    
2. 第二范式：第二范式且要求每一个非主属性都完全函数依赖于码。避免了Sdept、 Sloc部分函数依赖于码。问题：在一个包含学生和课程的表格中，只存储课程信息时需要提供学生ID。
3. 第三范式：避免传递函数依赖。比如一个系确定都住在哪，修改/插入/删除会出现问题。保证了没有对码的传递函数依赖。这里的传递函数依赖是指本来也有直接函数依赖但是不能有新的传递函数依赖。**仍可能需要不必要的信息来确保数据完整性。例如，插入一个新课程时如果课程的教授信息未单独存储，需要同时插入教授信息。**
    1. 自然的要求了第二范式
    2. **如果有多个候选码，每个都是主属性**
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2010.png)
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2011.png)
    
    问题：如果老师的学生都毕业了可能会找不到
    
4. BC范式：对于R的每一个函数依赖都必须含有码。R中的所有属性(主,非主属性)都完全函数依赖于码;**去掉了主属性对码的部分/传递函数依赖**
    1. 如果第三范式只有一个候选码，那么就是bc范式。因为果有两个候选码才会出现对另一个候选码的传递/部分函数依赖，如果只有自己没法自己对自己部分/函数传递依赖
5. 如果全是主属性，第三范式。如果只有两个属性，bc范式，如果全码，bc范式

规范化度越高不一定越好，规范化实质上是概念的单一化

### 数据依赖公理系统

判断候选码，找最小函数依赖集

定义6.11 对于满足一组函数依赖 F 的关系模式R <U,F>,其任何一个关系r,若函数依赖X→Y 都成立, 则称  F 逻辑蕴含X →Y

**F是指函数依赖**

在关系模式R(U,F)中为F所逻辑蕴含的函数依赖的全体,叫作  F的闭包,记为 F+。

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2012.png)

不断判断新加入的能不能确定新的，判断有没有新加入的

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2013.png)

如果x不是，那么从y中一个一个加进来试，对于还是不满足的两个两个试

两个函数依赖集等价充要条件是闭包等价

定义15 如果函数依赖集F满足下列条件,则称F为一个极小函数依赖集。亦称为最小依赖集或最小覆盖。  (1) F中**任一函数依赖的右部仅含有一个属性**。  (2) F中不存在这样的函数依赖X→A,使得F与F-{X→A}等价。  (3) F中不存在这样的函数依赖X→A,X有真子集Z使得F-{X→A}∪{Z→A}  与F等价。

求解最小依赖集：先右侧单一化，然后删东西

**注意这里的集合的元素是函数依赖！！**

- 关系模式分解
    - 无损连接性:进行关系分解后得到的关系按照外码自然连接能够得到原来的关系。
    - 函数依赖性:关系分解后每个关系的最小函数依赖集是原关系的最小函数依赖集的子集,并且所有子集的并等于原关系的最小函数依赖集。

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2014.png)

## SQL

1. 综合统一  集数据定义语言(DDL),数据操纵语言(DML),数据控制语言(DCL)功能  于一体。
2. 高度非过程化  
3. 面向集合的操作方式  
4. 以同一种语法结构提供两种使用方法  能够嵌入到高级语言
5. 语言简洁,易学易用

### 数据定义

CREATE, DROP, ALTER, DELETE

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2015.png)

1. CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
    1. 没有指定<模式名>,那么<模式名>隐含为<用户名>
    2. 在CREATE SCHEMA中可以接受CREATE TABLE,CREATE VIEW和GRANT子句
2. DROP SCHEMA <模式名><CASCADE|RESTRICT>
    1. CASCADE(级联)  删除模式的同时把该模式中所有的数据库对象全部删除。  
    2. RESTRICT(限制)  如果该模式中定义了下属的数据库对象(如表、视图等),则拒绝该删除语句的执  行,没有任何下属的对象时才能执行。
3. CREATE TABLE “模式名” .<表名>  (<列名> <数据类型>[ <列级完整性约束条件> ]  [,<列名> <数据类型>[ <列级完整性约束条件>] ]  ...  [,<表级完整性约束条件> ] );
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2016.png)
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2017.png)
    
    SET search_path TO “S-T”,PUBLIC;设置默认模式
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2018.png)
    
    ALTER TABLE Course ADD UNIQUE(Cname);
    
    ALTER TABLE Student ALTER COLUMN Sage INT;
    
    ALTER TABLE Student ADD S_entrance DATE;
    
    DROP TABLE <表名> [RESTRICT | CASCADE];
    
4. 索引 DBA或表的属主(即建立表的人)根据需要建立。 有些DBMS自动建立PRIMARY KEY，UNIQUE列上的索引
    
    CREATE [UNIQUE] [CLUSTER] INDEX <索引名>  ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]...);
    
    1. 缺省值:ASC
    2. UNIQUE表明此索引的每一个索引值只对应唯一的数据记录，对于已含重复值的属性列不能建UNIQUE索引  ◈对某个列建立UNIQUE索引后,插入新记录时DBMS会自动检查新记录  在该列上是否取了重复值。相当于增加了一个UNIQUE约束
    3. CLUSTER表示要建立的索引是聚簇索引，聚簇索引的索引项顺序与表中记录的物理顺序一致，一个基本表上最多只能建立一个聚簇索引，经常更新的列不宜建立聚簇索引
    
    ALTER INDEX <旧索引名> RENAME TO <新索引名> ;
    
    DROP INDEX <索引名>;
    

### 数据查询

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2019.png)

LIMIT <行数1> OFFSET <行数2>

SELECT *

SELECT Sname NAME,'Year of Birth: ’ BIRTH,  2014-Sage BIRTHDAY,ISLOWER(Sdept) DEPARTMENT  

FROM Student;

默认为ALL，DISTINCT去掉重复

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2020.png)

WHERE Sage BETWEEN 20 AND 23;

WHERE Sdept IN ( 'IS','MA','CS' );

- **% (百分号):代表任意长度(长度可以为0)的字符串**
- **_ (下横线):代表任意单个字符**
- 通配符换为普通字符：WHERE Cname LIKE 'DB\_Design' ESCAPE '\';

大多数数据库空为最大

1. 聚集函数:  

◈ 计数  COUNT([DISTINCT|ALL] *) (统计元组个数，**会处理空值**)  COUNT([DISTINCT|ALL] <列名>) (统计一列中值的个数)  

◈ 计算一列值的总和  SUM([DISTINCT|ALL] <列名>)   数值型

◈ 计算一列值的平均值  AVG([DISTINCT|ALL] <列名>)  数值型

◈ 求一列值中的最大最小值  MAX([DISTINCT|ALL] <列名>)  MIN([DISTINCT|ALL] <列名>)

SELECT COUNT(DISTINCT Sno)

查询学生201215012选修课程的总学分数。  **没有自然连接，需要限制！**

```jsx
SELECT SUM(Ccredit)  

FROM SC,Course  

WHERE Sno='201215012' AND SC.Cno=Course.Cno;
```

**WHERE子句中不能用聚集函数作为条件表达式。**

1. 分组
    
    对查询结果分组后,聚集函数将分别作用于每个组
    
    SELECT Sno, AVG(Grade)  
    
    FROM SC  
    
    GROUP BY Sno  
    
    HAVING AVG(Grade)>=90;（作用于组）
    

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2021.png)

### 连接查询（多表）

SQL中连接查询的主要类型  

- 等值连接(含自然连接)  、非等值连接查询
    - 任何子句中引用表1和表2中同名属性时,都必须加表名前缀。引用唯一属性名时可以  加也可以省略表名前缀。
    - 需要把重复列去掉
- 自身连接查询 （先修课的先修课）
    - 给表别名SELECT FIRST.Cno,SECOND.Cpno  FROM Course FIRST,Course SECOND  WHERE FIRST.Cpno = SECOND.Cno and SECOND.Cpno IS NOT NULL;
- 外连接查询
    
    SELECT Student.Sno,Sname,Ssex,  Sage,Sdept,Cno,Grade  
    
    FROM Student **LEFT OUTER JOIN** SC ON  (Student.Sno = SC.Sno);
    
- 复合条件连接查询
- 嵌套查询，子查询中不能有ordered by，子查询要放在比较符后面
- 相关子查询
    - 首先取外层查询中表的第一个元组,根据它与内层查询相关的属性值处理  内层查询,若WHERE子句返回值为真,则取此元组放入结果表;
    - 然后再取外层表的下一个元组;
    - 重复这一过程,直至外层表全部检查完为止。
    - SELECT Sno,Cno  FROM SC x
        
        WHERE Grade >= (SELECT AVG(Grade)  
        
                                    FROM SC y  
        
                              WHERE y.Sno=x.Sno);
        
    - 
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2022.png)
    
    SELECT Sname,Sage  
    
    FROM Student  WHERE Sage <  (SELECT MAX(Sage)  
    
                                                 FROM Student  WHERE Sdept= ' CS ')  AND Sdept <> ' CS ’;
    
    注意max不能对子查询返回的集合进行操作
    
- ANY和ALL谓词

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2023.png)

- 存在谓词：只产生逻辑真值“true”或  逻辑假值“false”
- 全程量词：(forall x)P ≡ not(存在 x(not P))
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2024.png)
    
- 逻辑蕴含：p→q = not p or q)
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2025.png)
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2026.png)
    
    这里可不可以加一层course呢
    
    SELECT DISTINCT Sno  
    
    FROM SC SCX  
    
    WHERE NOT EXISTS  (SELECT *  
    
    FROM COURSE CS
    
    WHERE EXISTS (SELECT*
    
    FROM SC SCY  
    
    WHERE SCY.Sno = ' 201215122 ' AND  SCY.Cno=CS.Cno AND NOT EXISTS  (SELECT *  
    
    FROM SC SCZ  
    
    WHERE SCZ.Sno=SCX.Sno AND  SCZ.Cno=SCY.Cno)));
    
- 集合操作 参加集合操作的各查询结果的列数必须相同;对应项的数据类型  也必须相同。
    - UNION两个集合
    - INTERSECT
        
        ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2027.png)
        
- 派生查询：子查询可以出现在FROM中，注意不要忘记写条件，可以给新表的列命名
    
    ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2028.png)
    

### 数据更新

- 插入一个元组，如果不指定任何属性列,则新插入的元组必须在每个属性列上均有值; 如果仅指定部分属性列,则新元组在没有出现的属性列上取空值
    
    INSERT  INTO <表名> [(<属性列1>[,<属性列2 >...)]  VALUES (<常量1> [,<常量2>] ... )
    
    INTO Student (Sno,Sname,Ssex,Sdept,Sage)
    
- 插入子查询结果
    
    INSERT  INTO <表名> [(<属性列1> [,<属性列2>... )]  子查询;
    
- UPDATE <表名>  SET <列名>=<表达式>[,<列名>=<表达式>]...  [WHERE <条件>];
- DELETE  FROM <表名>  [WHERE <条件>]
- 

### 空值

SQL语言允许某些元组的某些属性在一定情况下取空值:  

- 该属性应该有一个值,但目前不知道它的具体值;
- 该属性不应该有值;
- 某种原因不便于填写;

空值与另一个值(包括另一个空值)的算术运算结果为空值;  空值与另一个值(包括另一个空值)的比较运算结果为UNKNOWN; **这会导致比较的时候需要判断一下是不是nul**

### important

**字符串用’表示！**

**多表查询不要忘记连接条件**

**聚集函数（比如SUM，AVG不能出现在WHERE中**

### 视图

虚表,是从一个或几个基本表(或视图)导出的表;

其实就是查询条件

查询  **可以删除(只影响视图本身)  ▣ 受限更新(直接影响基本表)**  ▣ 定义基于该视图的新视图

CREATE VIEW <视图名> [(<列名> [,<列名>]...)]  AS <子查询>  [WITH CHECK OPTION];

WITH CHECK OPTION表示对视图进行更新、插入或删除操作时,要保证满足  视图定义中的谓词条件(子查询条件表达式)。

组成视图的属性列名:全部省略或全部指定。但在下面三种情况必须明确  指定组成视图的所有列名:  1)某个目标列不是单纯的属性名,而是聚集函数或列表达式;  2)多表连接时选出了几个同名列作为视图的字段;  3)需要在视图中为某个列启用新的更合适的名字。

CREATE VIEW语句时只是把视图的定义存入数据字典,并不执行其  中的SELECT语句。

DROP VIEW <视图名>[CASCADE];

视图消解法把视图定义中的子查询与用户的查询结合起来,转换成等价的对基本表的查询; 执行修正后的查询。

## 数据库设计

### 数据库设计概述

数据库设计是指对于一个给定的应用环境,构造(设计)优化的数  据库逻辑模式和物理结构,并据此建立数据库及其应用系统,使之能  够有效地存储和管理数据,满足各种用户的应用需求,包括信息管理  要求和数据操作要求。

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2029.png)

数据库设计分6个阶段:  ◈ 需求分析  ◈ 概念结构设计  ◈ 逻辑结构设计  ◈ 物理结构设计  ◈ 数据库实施  ◈ 数据库运行和维护  ▣ 需求分析和概念设计独立于任何数据库管理系统;  ▣ 逻辑设计和物理设计与选用的DBMS密切相关;

### 需求设计

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2030.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2031.png)

- 数据字典是各类数据描述的集合，包括数据项  ◈ 数据结构  ◈ 数据流  ◈ 数据存储  ◈ 处理过程
    - 数据定义语句就是更新数据字典中响应信息
    - 数据项描述={数据项名,数据项含义说明,  别名,数据类型,长度,取值范围,  取值含义,与其他数据项的逻辑关系,  数据项之间的联系}  ◈ 取值范围、与其他数据项的逻辑关系定义了数据的完整性约束条件;
    - 数据结构由若干个数据想构成

### 概念结构设计

需求分析阶段描述的用户应用需求是现实世界的具体需求

将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念  结构设计;

概念结构设计的特点:  (1)能真实、充分地反映现实世界,包括事物和事物之间的联系,能满足用户对数据的处理要求。  (2)易于理解,从而可以用它和不熟悉计算机的用户交换意见。  (3)易于更改,当应用环境和应用要求改变时,容易对概念模型修改和扩充  (4)易于向关系、网状、层次等各种数据模型转换。

E-R图

设计方法：自顶向下/自底向上/逐步扩张/混合策略——自顶向下地进行需求分析  ◈自底向上地设计概念结构

参照数据流图,标定各局部应用中的实体、实体的属性、标识实体的码。

尽量作为属性——属性不可分，不能与其他实体联系

概念结构设计的步骤:  ◈ 抽象数据并设计局部视图。  ◈ 集成局部视图,得到全局概念结构。  ◈ 验证整体概念结构。

### 视图的集成

1. 属性冲突
    1. 两类属性冲突  
        1. 属性域冲突:属性值的类型、取值范围或取值集合不同
        2. 属性取值单位冲突。
2. 命名冲突
    1. 同名异义:不同意义的对象在不同的局部应用中具有相同的名字
    2. 异名同义
3. 结构冲突
    1. 同一对象在不同应用中具有不同的抽象;  
    2. 同一实体在不同分E-R图中所包含的属性个数和属性排列次序不完全相同;  
    3. 实体之间的联系在不同局部视图中呈现不同的类型;

冗余的数据是指可由基本数据导出的数据,  冗余的联系是指可由其他联系导出的联系。  ▣ 冗余数据和冗余联系容易破坏数据库的完整性,

以数据字典和数据流图为依据,根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。

若人为地保留了一些冗余数据,则应把数据字典中数据关联的说明作为完整性约束条件。

写出函数依赖→求最小覆盖，逐一检查原先的和最小覆盖的差集，确定是否是冗余

班级和班长（某个学生）有一对一关系，班级和学生有一对多的关系，两个关系都要画到e-r图中

**仓库和部门可以合并**

### 逻辑结构设计

- E-R图由实体、实体的属性和实体之间的联系三个要素组成
- 关系模型的逻辑结构是一组关系模式的集合
- 将E-R图转换为关系模型:将实体、实体的属性和实体之间的联系转化为关系模式。
1. 每个实体型转化为一个关系模式。关系的属性:实体型的属性  关系的码:实体型的码
2. 一个m:n联系转换为一个关系模式。
    1. 关系的属性:与该联系相连的各实体的码以及联系本身的属性  
    2. 关系的码:各实体码的组合
3. 一个1:n联系可以转换为一个独立的关系模式,也可以与n端对应的关系模式合并
4. 一个1:1联系可以转换为一个独立的关系模式,也可以与任意一端对应的关系模式合并。
5. 三个或三个以上实体间的一个多元联系转换为一个关系模式。  
    1. 关系的属性:与该多元联系相连的各实体的码以及联系本身的属性  
    2. 关系的码:各实体码的组合
6. 具有相同码的关系模式可合并

**用波浪线表示外码！，主码加下划线**

数据模型的优化

1. 确定数据依赖
2. 消除冗余的联系
3. 确定所属范式
4. 按照需求分析阶段得到的各种应用对数据处理的要求,分析对于这样  的应用环境这些模式是否合适,确定是否要对它们进行合并或分解。
- 水平分解把(基本)关系的元组分为若干子集合,定义每个子集合为一个子关系,  以提高系统的效率，满足“80/20原则”的应用
- 垂直分解  • 把关系模式R的属性分解为若干子集合,形成若干子关系模式。（了解一下）

### 数据库物理设计

数据库在物理设备上的存储结构与存取方法称为数据库的物理结构,它依赖于选定的数据库管理系统

设计的内容

1. 为关系模式选择存取方法(建立存取路径)  
    1. 索引方法,  
        1. B+树索引  
            1. 属性经常在查询条件中出现
            2. 作为最大值和最小值等聚集函数的参数
            3. 在连接操作的连接条件中出现
        2. Hash索引 
            1. 择hash索引存取方法的一般规则:  
                1. 一个关系的属性主要出现在等值连接条件;  
                2. 一个关系的属性主要出现在等值比较选择条件;  
                3. 而且满足下列两个条件之一:  ü 一个关系的大小可预知,而且不变;  ü 关系的大小动态改变,但DBMS提供了动态hash存取方法。
    2.  聚簇(Cluster)方法
        
        为了提高某个属性(或属性组)的查询速度,把这个或这些属性(称为聚簇码)  上具有相同值的元组集中存放在连续的物理块称为聚簇。
        
        聚簇以后,聚簇码相同的元组集中在一起了,因而聚簇码值不必在  每个元组中重复存储
        
        多表预连接：可以把具有  相同学号值的学生元组和选修元组在物理上聚簇在一起。
        
        从独立聚簇中删除经常进行全表扫描的关系;  删除更新操作远多于查询操作的关系;  u 从独立/组合聚簇中删除重复出现的关系
        
        当通过聚簇码进行访问或连接是该关系的主要应用,与聚簇码无关的其他访问很少  或者是次要的时,可以使用聚簇。
        
2. 设计关系、索引等数据库文件的物理存储结构

数据库的重组织不会改变原设计的数据逻辑结构和物理结构

## 数据库编程

SQL高度非过程化查询语言，缺少流程控制能力  难以实现业务中的逻辑控制

### 扩展SQL语句

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2032.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2033.png)

### 高级语言调用

- 通过动态链接库调用的方式
- 嵌入式SQL的方式
- 基于ODBC/JDBC的中间件方式

### 过程化SQL

基本结构是块  块之间可以互相嵌套，每个块完成一个逻辑操作

定义部分  DECLARE 变量、常量、游标、异常等

执行部分  BEGIN  SQL语句、过程化SQL的流程控制语句  EXCEPTION  异常处理部分  END;

当查询返回多条记录时,就要使用游标对结果集进行处理。一个游  标与一个SQL语句相关联。

- 存储过程，过程化SQL程序也可以被命名和编译,并保存  在数据库中
    
    ```jsx
    CREATE OR REPLACE PROCEDURE过程名(  
    [[IN|OUT|INOUT] 参数1 数据类型,  
    [IN|OUT|INOUT] 参数2 数据类型,  ...]  
    ) /*存储过程首部*/  
    AS <过程化SQL块>; /*存储过程体,描述该存储过程的操作*/
    ```
    
    CREATE OR REPLACE PROCEDURE compGPA( /*定义存储过compGPA*/  
    
    IN inSno CHAR(10), /*输入参数:学生学号inSno*/  
    
    OUT outGPA FLOAT) /*输出参数:平均学分绩outGPA*/  
    
    AS 
    
    DECLARE  courseGPA INT; /*声明变量courseGPA,临时存储课程学分绩 */  totalGPA INT; /*声明变量totalGPA,临时存储总学分绩 */  totalCredit INT; grade INT; /*声明变量grade,临时存储学生成绩 */  credit INT; /*声明变量credit ,临时存储课程学分 */  
    
    mycursor CURSOR FOR /*声明游标mycursor */  
    
    SELECT Ccredit, grade FROM SC, Course  WHERE Sno = inSno and SC.Cno = Course.Cno;  
    
    BEGIN  totalGPA := 0;  totalCredit := 0;  
    
    OPEN mycursor; /*打开游标mycursor */
    
    LOOP /*循环遍历游标*/  
    
    FETCH mycursor INTO credit, grade; /*检索游标*/  
    
    EXIT WHEN mycursor%NOTFOUND;  
    
    IF grade BETWEEN 90 AND 100 THEN courseGPA := 4.0;  ELSIF grade BETWEEN 80 AND 89 THEN courseGPA := 3.0;  ELSIF grade BETWEEN 70 AND 72 THEN courseGPA := 2.0;  ELSIF grade BETWEEN 60 AND 69 THEN courseGPA := 1.0;  ELSE courseGPA := 0;  END IF; /*参照表6.2,根据成绩找出某门课程对应的学分绩点*/
    
    totalGPA := totalGPA + courseGPA * credit;  totalCredit := totalCredit + credit;  
    
    END LOOP;  
    
    CLOSE mycursor; /*关闭游标mycursor */  
    
    outGPA := 1.0 * totalGPA / totalCredit;  
    
    END;
    
    下面说一个过程化sql块，调用了上面的过程
    
    DECLARE outGPA FLOAT;  
    
    BEGIN  CALLcompGPA(‘20180001’,outGPA);  RAISE NOTICE ‘GPA: %’, outGPA;  END;
    
    - 修改存储过程
        - 重命名  ALTER PROCEDURE 过程名1 RENAME TO 过程名2;
        - 重新编译  ALTER PROCEDURE 过程名COMPILE;
    - 删除存储过程  DROP PROCEDURE 过程名;
- 存储函数，换乘function，必须有returns as

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2034.png)

## 数据库安全

数据库的安全性,是指保护数据库以防止不合法使用所造成的数据泄漏、更改或破坏。

保密性，安全性，可用性，完整性、

### 存取机制

存取控制机制的组成:  ◈ 定义用户存取权限◈合法存取权限检查

常用存取控制方法:  

- 自主存取控制(Discretionary Access Control ,简称DAC)  用户对不同的数据对象有不同的存取权限,不同的用户对同一对象也有不同的权限,用户还  可将其拥有的存取权限转授给其他用户。  • C2级  • 灵活
    - GRANT  ▣ GRANT语句的一般格式:  GRANT <权限>[,<权限>]...（SELECT， ALL PRIVILIGES/UPDATE(Sno)）  [ON <对象类型> <对象名>]  TO <用户>[,<用户>]（PUBLIC）...  [WITH GRANT OPTION];  ▣ 语义:将对指定操作对象的指定操作权限授予指定的用户。WITH GRANT OPTION子句：是否可以传播
        
        GRANT INSERT ON TABLE SC TO U6  WITH GRANT OPTION;
        
    - REVOKE 权限 ON FROM CASCADE（强制级联收回）
    - CREATE USER <username>  [WITH][DBA | RESOURCE | CONNECT]
        
        ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2035.png)
        
    - 数据库角色:被命名的一组与数据库操作相关的权限。角色是权限的集合
        - CREATE ROLE <角色名>
        - GRANT <角色1>[,<角色2>]...  TO <角色3>[,<用户1>]...  [WITH ADMIN OPTION]
        - 角色可以用上面的语句进行授权和取消
    - 授权粒度是指可以定义的数据对象的范围。授权定义中数据对象的粒度越细,即可以定义的数据对象的范围越小,  授权子系统就越灵活。
    - 可能出现复制一份没有新的要求的
- 强制存取控制(Mandatory Access Control,简称 MAC)每一个数据对象被标以一定的密级,每一个用户也被授予某一个级别的许可证。对任意一  个对象,只有具有合法许可证的用户才可以存取。  – B1级
    - 分为主体/客体，为它们每个实例(值)指派一个敏感度标记
    - 仅当主体的许可证级别大于或等于客体的密级时,该主体才能读取相应的客体;
    - 仅当主体的许可证级别小于或等于客体的密级时,该主体才能写相应的客体。
    - 无论数据如何复制,标记与数据是一个不可分的整体
- 实现MAC时要首先实现DAC

### 审计

用一个专用的审计日志(Audit Log)  将用户对数据库的所有操作记录在上面;

AUDIT ALTER,UPDATE  ON SC;

NOAUDIT ALTER,UPDATE  ON SC;

### 数据加密

存储空间不应明显增，解密速度要快，不应影响系统原有功能，灵活的密钥管理机制，允许用户以不同的粒度对之进行访问

可考虑在三个不同层次实现对数据库数据的加密,这三个层次  分别是OS、DBMS内核层和DBMS外层;

OS很难，内核层DBMS和加密器(硬件  或软件)之间的接口需要DBMS开  发商支持;

- 外层加密
    - 一般而言,数据库系统中每条记录所包含的信息具有一定的封闭性,  它独立完整存储了一个实体的数据,因此基于记录的加密技术最常  用,每条记录在各自密钥作用下加密成密文信息;
    - 数据项加密:  u 数据项加密是以记录中每个字段的值为单位进行加密,数据项是数  据库中最小的加密粒度;

存储加密  

- 透明存储加密  ü 内核级加密保护方式,对用户完全透明;  ü 数据写到磁盘时对数据进行加密,授权用户读取数据时解密;  ü 应用程序不需要修改,只需在创建表语句中说明需加密字段;  ü 性能较好,安全完备性较高;
- 非透明存储加密,是通过多个加密函数实现;

传输加密

链路加密  

- 对传输数据在链路层加密,  传输信息由报头和报文两部分组成,  报头和报文均加密;
- 端到端加密

### 推理控制

1. 任何查询至少要涉及N(N足够大)个以上的记录
2. 任意两个查询的相交数据项不能超过M个
3. 任一用户的查询次数不能超过1+(N-2)/M

## 数据库完整性

**一定不要忘记定义主码和外码！**

数据库的完整性(integrity)是指数据的正确性(correctness)  和相容性(compatability);  

- 数据的正确性:是指数据符合现实世界语义、反映当前实际状况;
- 数据的相容性:是指数据库同一对象在不同关系表中的数据是符合逻辑的;

DBMS的完整性控制机制

- 定义完整性约束条件的机制
- 提供完整性检查的方法
- 进行违约处理

约束条件

- 静态约束 对静态对象的约束是反映数据库状态合理性的约束;
- 动态约束  对动态对象的约束是反映数据库状态变迁的约束;

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2036.png)

### 实体完整性

主码唯一且非空，可以用B+树

### 参照完整性

FOREIGN KEY子句:定义外码列   REFERENCES子句:外码相应于哪个表的主码  

级联(CASCADE)操作:在删除或修改被参照关系的元组时,同时删除或修改参照关系所有导致不一致的元组

违约处理  

- 拒绝 (NO ACTION):不允许该操作执行(默认策略);
- 级联 (CASCADE):当删除或修改被参照表的一个元组导致与参照表  不一致时,删除或修改参照表中所有导致不一致的元组;
- 设置为空值:当删除或修改被参照表的一个元组导致与参照表不一致  时,将参照表中所有造成不一致的元组的对应属性设置为空值;

FOREIGN KEY (Sno) REFERENCES Student(Sno) /* 在表级定义参照完整性*/  ON DELETE CASCADE /* 删除Student元组时,级联删除SC中相应元组*/  ON UPDATE NO ACTION, /* 更新Student表中Sno时,级联更新SC中

### 用户定义的完整性

属性上的完整性约束：Dname CHAR(9) UNIQUE NOT NULL CHECK (Sage < 29),

CHECK (Ssex=‘女’OR Sname NOT LIKE‘MS.%’)

### 完整性约束命名字句

CONSTRAINT <完整性约束条件名> <完整性约束条件>  

ALTER TABLE Student DROP CONSTRAINT C1;

ALTER TABLE Student  ADD CONSTRAINT C1 CHECK(Sno BETWEEN 900000 AND 999999);

<完整性约束条件>包括NOT NULL、UNIQUE、PRIMARY KEY、  FOREIGN KEY、CHECK短语等;

### 断言

断言创建后,任何对断言中所涉及关系的操作都会触发RDBMS  对断言的检查,任何使断言不为真值的操作都会被拒绝执行;

CREATE ASSERTION <断言名> <CHECK 子句>

CREATE ASSERTION ASSE_SC_DB_NUM  

CHECK (60 >= (SELECT count (*) /* 此断言的谓词涉及聚集操作count*/  FROM Course, SC  WHERE SC.CNO=COURSE.CNO AND COURSE.CNAME =‘数据库’));

CREATE ASSERTION ASSE_SC_CNUM2  

CHECK (60 >= ALL(SELECT count (*) /* 此断言的谓词涉及聚集操作count*/  

FROM SC /* 和分组函数group by的SQL语句*/  

GROUP by Cno,TERM));

DROP ASSERTION <断言名>

### 触发器

触发器又叫做事件-条件-动作(event-condition-action)规则

只有表的拥有者,即创建表的用户,才可以在表上创建触发器

触发器按照所触发动作的间隔尺寸可分为行级触发器(FOR EACH ROW)  和语句触发器(FOR EACH STATEMENT);  n 默认的触发器是语句级触发器;

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2037.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2038.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2039.png)

## 存储管理

- 顺序表索引：在顺序表的排序属性(组)上建立索引;  也称作主索引(Primary Index)或聚簇索引(Clustering Index);
    - 稠密索引，给每个学号都简历索引
        
        ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2040.png)
        
    - 稀疏索引 基本表的每个物理存储块只对应一个索引项
    - 多级索引
- 辅助索引(Secondary Index)
    - 建立在表的非排序属性上的索引;
    - 一个表最多只能建立一个主索引,但可以在不同属性上建立多个  辅助索引;
    - 辅助索引必须是稠密索引;
        
        ![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2041.png)
        

一个哈希桶对应一个哈希值装很多个

当溢出桶空间充满时,追加新的溢出桶  l用溢出链将一个桶及其溢出桶链接在一起

两类动态哈希索引:  可扩展哈希索引  线性哈希索引

### 位图索引

长度为n的位向量集合  n:索引属性的基数(可能取值的个数) ，每一个位向量对应于索引属性的一个可能的取值

如果第i条记录的索引属性值为v,那么对应于值v的位向  量在位置i上取值为1,其他的位向量在位置i上取值为0。比如男女为10，01

有效处理多值查询（比如两个向量的某一位进行与

基数大的列其位图索引会非常庞大,  因此它只适用于基数小的属性列

连接操作：

- 嵌套循环算法(nested loop join)
- 排序-合并算法(sort-merge join 或merge join)  每个表都只要扫一遍
- 索引连接算法(index join)   建立对Sno对索引
- 哈希连接算法 (hash join)

### 查询处理和优化

关系数据库管理系统通过某种代价模型计算出各种查询执行  策略的执行代价,然后选取代价最小的执行方案

对于选择条件是“非主属性 比较 值”的查询,并且选择列上有索引，要估算查询结果的元组数目。如果比例较小(<10%)可以使用索引扫描方法  l 否则还是使用全表顺序扫描

### 查询计划的执行

自顶向下

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2042.png)

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2043.png)

简单了解

## 数据库恢复

数据库管理系统对故障的对策:  

- DBMS提供恢复子系统;
- 保证故障发生后,能把数据库从错误状态恢复到某种逻辑一致  的状态(某一已知的正确状态);
- 保证事务ACID;

事务(Transaction)是用户定义的一个数据库操作序列,这些操作要  么全做,要么全不做,是一个不可分割的工作单位

COMMIT (提交)

ROLLBACK (回滚)

事务的ACID特性:  

- 原子性(Atomicity)
    - 事务中包括的诸操作要么都做,要么都不做;
- 一致性(Consistency)
    - 一致性状态  数据库中只包含成功事务提交的结果;
    - 不一致状态(不正确状态)  数据库系统运行故障,数据库中包含失败事务的结果;
- 隔离性(Isolation)
    - 对并发执行而言,一个事务的执行不能被其他事务干扰。
- 持续性(Durability )
    - 一个事务一旦提交,它对数据库中数据的改变就应该是永久性的

故障种类

- 事务故障
    - 转钱发现余额不足
    - 事务故障的恢复:事务撤消(UNDO)
    - 强行回滚(ROLLBACK)该事务
    - 恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进  行的修改
- 系统故障
    - 停电
    - 清除尚未完成的事务对数据库的所有修改
        - 系统重新启动时,恢复程序要强行撤消(UNDO)所有未完成事务;  将缓冲区中已完成事务提交的结果写入数据库
        - 恢复程序需要重做(REDO)所有已提交的事务;
- 介质故障
    - 硬件故障使存储在外存中的数据部分丢失或全部丢失,  并影响正在存取这部分数据的所有事务
    - 装入数据库发生介质故障前某个时刻的数据副本;  重做自此时开始的所有成功事务,将这些事务已提交的  结果重新记入数据库;
    - 重装备份恢复到一致性+REDO
- 计算机病毒

恢复机制涉及的关键问题  如何建立冗余数据  

恢复中最经常使用的技术:数据库转储和登记日志文件

### 数据转储

- 静态转储
    - 在系统中无运行事务时进行转储;  转储开始时数据库处于一致性状态;  转储期间不允许对数据库的任何存取、修改活动;
    - 降低了数据库的可用性
- 动态转储
    - 能保证副本中的数据正确有效
    - 需要把动态转储期间各事务对数据库的修改活动登记下来,建立日志文件(log file);  后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态
- 海量转储: 每次转储全部数据库;  增量转储: 只转储上次转储后更新过的数据;  海量转储与增量转储比较:
    - 从恢复角度看,使用海量转储得到的后备副本进行恢复往往更方便;
    - 但如果数据库很大,事务处理又十分频繁,则增量转储方式更实用  更有效

### 登记日志文件

日志文件(log)是用来记录事务对数据库的更新操作的文件;

日志文件内容  

- 各个事务的开始标记(BEGIN TRANSACTION)
- 各个事务的结束标记(COMMIT或ROLLBACK)
- 各个事务的所有更新操作
- 与事务有关的内部更新操作

均为日志文件中的一个日志记录 (log record)

必须先写日志文件,后写数据库;  

写日志文件操作:把表示这个修改的日志记录写到日志文件;  

写数据库操作:把对数据的修改写到数据库中;

在日志文件中增加检查点记录

1. 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上;  
2. 在日志文件中写入一个检查点记录;  
3. 将当前数据缓冲区的所有数据记录写入磁盘的数据库中;  
4. 把检查点记录在日志文件中的地址写入一个重新开始文件;

## 并发控制

多事务执行方式  

- 事务串行执行  每个时刻只有一个事务运行,其他事务必须等到这个事务结束以后  方能运行;
    - 不能充分利用系统资源,发挥数据库共享资源的特点;
- 交叉并发方式(interleaved concurrency)  在单处理机系统中,事务的并行执行是这些并行事务的并行操作轮  流交叉运行;  能够减少处理机的空闲时间,提高系统的效率。
- 同时并发方式(simultaneous concurrency)  多处理机系统中,每个处理机可以运行一个事务,多个处理机可以  同时运行多个事务,实现多个事务真正的并行运行;
    - 问题：
        - 丢失修改指事务1与事务2  从数据库中读入同一数据并  修改;
        - 不可重复读：事务1读取数据后,事务2执行更新操作,  使事务1无法再现前一次读取结果
        - 读“脏”数据：2读了1的数据后被撤销

主要技术

- 封锁(locking)
- 时间戳(timestamp)
- 乐观控制法(optimistic scheduler)
- 多版本并发控制(multi-version concurrency control, MVCC)

### 封锁

在对某个数据对象(例如表、记录等)操作之  前,先向系统发出请求,对其加锁

- 派他锁 不能读取和修改
- 共享锁 T可以读但不能改，其他事务只能读，不能加X锁

封锁协议

- 一级封锁协议
    - 事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放。
        - 正常结束(COMMIT)
        - 非正常结束(ROLLBACK)
    - 不能保证可重复读和不读“脏”数据
- 二级
    - 在一级封锁协议基础上,增加事务T在读取数据R前必须先加S锁,  读完后即可释放S锁;
    - 不能  保证可重复读;
- 三级
    - 增加事务T在读取数据R前必须先加S锁,直到事务结束才释放;

### 活锁和死锁

避免活锁可以采用先来先服务的策略，建立一个队列

死锁

- 预防
    - 要求每个事务必须一次将所有要使用的数据全部加锁,  否则就不能继续执行;，但是可能会降低并发度
        - 进一步：将事务在执行过程中可能要封锁的数据对象全部加锁
    - 预先对数据对象规定一个封锁顺序，但是维护成本高
- 诊断和解除
    - 超时法 如果一个事务的等待时间超过了规定的时限,就认为发  生了死锁
        - 可能误判，时间不好确定
    - 等待图法：每隔一定时间检查回路，选择一个处理死锁代价最小的事务,将其撤消

### 并发调度的可串行性

将所有事务串行起来的调度策略一定是正确的调度策略

并发事务调度的执行结果等价于串行调度的调度也是正确的,  这样的调度叫做可串行化调度

以不同的顺序串行执行事务也有可能会产生不同的结果,但由于不会将数据库置于不一致状态,所以都可以认为是正确的

**多个事务的并行执行是正确的,当且仅当其结果与按某一次序串行地执行它们时的结果相同。这种并行调度策略称为可串行化(Serializable)调度。**

冲突操作是指不同的事务对同一个数据的读写操作和写写操作

不同事务的冲突操作和同一事务的两个操作是不能交换的

一个调度Sc在保证冲突操作的次序不变的情况下,通过交换两个事务不冲突操作的次序得到另一个调度Sc ́,如果Sc ́ 是串  行的,称调度Sc为冲突可串行化的调度。

冲突可串行化则可穿行化

### 两段锁协议

指所有的事务必须分两个阶段对数据项加锁和解锁:  

- 在对任何数据进行读、写操作之前,事务首先要申请并获得对该  数据的封锁;
- 在释放一个封锁之后,事务不再申请和获得任何其他封锁;

并行执行的所有事务均遵守两段锁协议,则对这些事务的所有并行调度策略都是可串行化的。

一次封锁法要求每个事务必须一次将所有要使用的数据全部  加锁,否则就不能继续执行,因此一次封锁法遵守两段锁协议;

两段锁协议:保证并发调度的正确性;   

三级封锁协议:在不同程度上保证数据一致性; 遵守第三级封锁协议必然遵守两段协议

### 封锁粒度

逻辑单元: 属性值、属性值集合、元组、关系、索引项、  整个索引、整个数据库等;  

物理单元:页(数据页或索引页)、物理记录等;  

多粒度封锁

- 多粒度树:以树形结构来表示多级封锁粒度;根结点是整个数据库,表示最大的数据粒度;  叶结点表示最小的数据粒度;
    - 允许多粒度树中的每个结点被独立地加锁;  对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁;  在多粒度封锁中一个数据对象可能以两种方式封锁:
        - 显式封锁直接加到数据对象上的封锁;
        - 隐式封锁由于其上级结点加锁而使该数据对象加上了锁;
        - 检查
            - 该数据对象有无显式封锁与之冲突;  所有上级结点
            - 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突(由上级结点封锁造成的);
            - 所有下级结点看上面的显式封锁是否与本事务的隐式封锁(将加到下级结点的  封锁)冲突。

### 意向锁

如果对一个结点加意向锁,则说明该结点的下层结点正在被加锁;  对任一结点加锁时,必须先对它的上层结点加意向锁;

提高对某个数据对象加锁时系统的检查效率。

- 意向共享锁(Intent Share Lock,简称IS锁)  表示它的后裔结点拟(意向)  加S锁
- 意向排它锁(Intent Exclusive Lock,简称IX锁)  表示它的后裔结点拟(意向)  加X锁
- 共享意向排它锁(Share Intent Exclusive Lock,简称SIX锁)  表示对它加S锁,再加IX锁

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2044.png)

同级别的可以互容，但是ix和任何不相容

具有意向锁的多粒度封锁方法:  

- 申请封锁时应该按自上而下的次序进行;
- 释放封锁时则应该按自下而上的次序进行;

![image.png](Database%2020ab7a22556a80c5ac34f4cfcf87c3bd/image%2045.png)

数据库的并发控制以事务为单位;

第27讲 22年考试卷